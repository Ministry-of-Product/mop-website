<!DOCTYPE html>
<html lang="{{ page.lang | default: site.lang | default: "en" }}">

  {%- include head.html -%}

  <body>

    {%- include header.html -%}

    <main class="page-content" aria-label="Content">
      <div class="page-container">
        <!-- Canvas for gooey raindrop effect -->
        <canvas id="rainCanvas" class="rain-canvas"></canvas>
        
        <div class="glass-content">
        {{ content }}
          {%- include footer.html -%}
        </div>
      </div>
    </main>

    <script>
      // Gooey Raindrop Effect
      class Drop {
        constructor(x, y, size = Math.random() * 8 + 4) {
          this.x = x;
          this.y = y;
          this.size = size;
          this.speed = size * 0.3 + Math.random() * 2 + 1; // Larger drops fall faster
          this.trail = [];
          this.maxTrailLength = Math.floor(size * 2);
          this.isSplatting = false;
          this.splatProgress = 0;
          this.opacity = 0.8;
          this.life = 1.0;
        }

        update() {
          if (this.isSplatting) {
            this.splatProgress += 0.005; // Very slow splat animation
            
            // Extremely gradual fade - drops stay visible much longer at bottom
            if (this.splatProgress < 0.3) {
              this.opacity = Math.max(0.6, this.opacity - 0.0005); // Barely any fade initially
            } else if (this.splatProgress < 0.6) {
              this.opacity = Math.max(0.4, this.opacity - 0.001); // Very slow fade
            } else if (this.splatProgress < 0.8) {
              this.opacity = Math.max(0.2, this.opacity - 0.002); // Still slow fade
            } else {
              this.opacity = Math.max(0, this.opacity - 0.003); // Gradual final fade
            }
            
            this.life -= 0.002; // Very slow life decay
            return this.life > 0;
          }

          // Add current position to trail
          this.trail.push({ x: this.x, y: this.y, size: this.size });
          if (this.trail.length > this.maxTrailLength) {
            this.trail.shift();
          }

          // Move down
          this.y += this.speed;

          // Check if reached bottom - let them fall all the way
          if (this.y > window.innerHeight - 20) {
            this.isSplatting = true;
            this.speed = 0;
            this.y = window.innerHeight - 20; // Keep them at the bottom
          }

          return true;
        }

        draw(ctx) {
          if (this.life <= 0) return;

          ctx.save();
          ctx.globalAlpha = this.opacity;

          if (this.isSplatting) {
            // Draw splat effect - more gradual and realistic
            const splatWidth = this.size * (1 + this.splatProgress * 1.5);
            const splatHeight = this.size * (1 - this.splatProgress * 0.3);
            
            // Add blur effect as the drop fades - more gradual
            const blurAmount = this.splatProgress * 2; // Less aggressive blur
            ctx.filter = `blur(${blurAmount}px)`;
            
            // Main splat with fading opacity
            ctx.beginPath();
            ctx.ellipse(this.x, this.y, splatWidth, splatHeight, 0, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${0.12 * this.opacity})`;
            ctx.fill();
            
            // Add a subtle glow effect that appears early and fades gradually
            if (this.splatProgress > 0.2) {
              ctx.beginPath();
              ctx.ellipse(this.x, this.y, splatWidth * 1.4, splatHeight * 1.4, 0, 0, Math.PI * 2);
              ctx.fillStyle = `rgba(255, 255, 255, ${0.04 * this.opacity})`;
              ctx.fill();
            }
            
            // Add an outer halo for mid-fade drops
            if (this.splatProgress > 0.4) {
              ctx.beginPath();
              ctx.ellipse(this.x, this.y, splatWidth * 1.8, splatHeight * 1.8, 0, 0, Math.PI * 2);
              ctx.fillStyle = `rgba(255, 255, 255, ${0.02 * this.opacity})`;
              ctx.fill();
            }
            
            // Add a very faint outer ring for heavily faded drops
            if (this.splatProgress > 0.7 && this.opacity < 0.3) {
              ctx.beginPath();
              ctx.ellipse(this.x, this.y, splatWidth * 2.2, splatHeight * 2.2, 0, 0, Math.PI * 2);
              ctx.fillStyle = `rgba(255, 255, 255, ${0.005 * this.opacity})`;
              ctx.fill();
            }
            
            // Reset filter
            ctx.filter = 'none';
          } else {
            // Draw main drop (elliptical head)
            ctx.beginPath();
            ctx.ellipse(this.x, this.y, this.size * 0.6, this.size, 0, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fill();

            // Draw trail with more realistic fading
            for (let i = 0; i < this.trail.length - 1; i++) {
              const point = this.trail[i];
              const nextPoint = this.trail[i + 1];
              const progress = i / this.trail.length;
              const trailSize = point.size * (0.2 + progress * 0.8);
              const trailAlpha = progress * 0.6;

              ctx.globalAlpha = this.opacity * trailAlpha;
              
              // Add slight blur to trail segments for more realistic water effect
              const trailBlur = progress * 0.5;
              ctx.filter = `blur(${trailBlur}px)`;
              
              ctx.beginPath();
              ctx.ellipse(point.x, point.y, trailSize * 0.3, trailSize * 0.7, 0, 0, Math.PI * 2);
              ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
              ctx.fill();
              
              ctx.filter = 'none';
            }
          }

          ctx.restore();
        }
      }

      class RainController {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');
          this.drops = [];
          this.lastSpawn = 0;
          this.spawnInterval = 0;
          this.maxDrops = 60; // Increased further since drops accumulate at bottom longer
          this.animationId = null;
          this.prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
          this.isLowPerformance = this.detectLowPerformance();
          
          this.resize();
          this.setupEventListeners();
          
          if (!this.prefersReducedMotion && !this.isLowPerformance) {
            this.start();
          } else if (this.isLowPerformance) {
            console.log('Rain effect disabled due to low performance detection');
            this.showPerformanceMessage();
          }
        }

        setupEventListeners() {
          window.addEventListener('resize', () => this.resize());
          
          // Add click to spawn raindrop functionality
          this.canvas.addEventListener('click', (e) => {
            if (this.prefersReducedMotion || this.isLowPerformance) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            
            // Spawn a drop at click position with a slightly larger size for visibility
            const size = Math.random() * 8 + 6; // Slightly larger for click-spawned drops
            this.drops.push(new Drop(x, y, size));
          });
          
          // Listen for reduced motion preference changes
          window.matchMedia('(prefers-reduced-motion: reduce)').addEventListener('change', (e) => {
            this.prefersReducedMotion = e.matches;
            if (this.prefersReducedMotion) {
              this.stop();
            } else {
              this.start();
            }
          });
        }

        resize() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
        }

        // Update drop positions to account for scroll
        updateDropPositions() {
          this.drops.forEach(drop => {
            if (!drop.isSplatting) {
              // Keep drops at their current viewport position
              // No need to adjust for scroll since canvas is fixed
            }
          });
        }

        spawnDrop() {
          // If at max drops, remove the oldest one to make room
          if (this.drops.length >= this.maxDrops) {
            this.drops.shift(); // Remove first (oldest) drop
          }
          
          const x = Math.random() * this.canvas.width;
          const y = -20; // Start above viewport
          const size = Math.random() * 8 + 4;
          
          this.drops.push(new Drop(x, y, size));
        }

        update() {
          const now = Date.now();
          
          // Spawn new drops
          if (now - this.lastSpawn > this.spawnInterval) {
            this.spawnDrop();
            this.lastSpawn = now;
            this.spawnInterval = Math.random() * 160 + 120; // 120-280ms
          }

          // Update existing drops
          this.drops = this.drops.filter(drop => drop.update());
        }

        render() {
          // Clear canvas
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          
          // Apply gooey effect with blur and blending
          this.ctx.filter = 'blur(1px)';
          this.ctx.globalCompositeOperation = 'screen';
          
          // Draw all drops
          this.drops.forEach(drop => drop.draw(this.ctx));
          
          // Reset filter and blending
          this.ctx.filter = 'none';
          this.ctx.globalCompositeOperation = 'source-over';
        }

        animate() {
          this.update();
          this.render();
          this.animationId = requestAnimationFrame(() => this.animate());
        }

        start() {
          if (!this.animationId) {
            this.animate();
          }
        }

        stop() {
          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          }
        }

        detectLowPerformance() {
          // Check for various performance indicators
          const checks = {
            // Check device memory (if available)
            lowMemory: navigator.deviceMemory && navigator.deviceMemory < 4,
            
            // Check hardware concurrency (CPU cores)
            lowCores: navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4,
            
            // Check connection speed (if available)
            slowConnection: navigator.connection && 
              (navigator.connection.effectiveType === 'slow-2g' || 
               navigator.connection.effectiveType === '2g'),
            
            // Check for mobile devices (generally less performant for canvas)
            isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
            
            // Check for older browsers
            oldBrowser: !window.requestAnimationFrame || !window.CanvasRenderingContext2D,
            
            // Check for reduced data usage preference
            saveData: navigator.connection && navigator.connection.saveData
          };

          // Count how many low-performance indicators are present
          const lowPerformanceCount = Object.values(checks).filter(Boolean).length;
          
          // Disable if 2 or more indicators suggest low performance
          const shouldDisable = lowPerformanceCount >= 2;
          
          if (shouldDisable) {
            console.log('Low performance detected:', checks);
          }
          
          return shouldDisable;
        }

        showPerformanceMessage() {
          // Add a subtle indicator that the rain effect is disabled for performance
          const message = document.createElement('div');
          message.style.cssText = `
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-family: 'Roboto', sans-serif;
            z-index: 10;
            opacity: 0.8;
            pointer-events: none;
          `;
          message.textContent = 'Rain effect disabled for better performance';
          document.body.appendChild(message);
          
          // Remove the message after 5 seconds
          setTimeout(() => {
            if (message.parentNode) {
              message.parentNode.removeChild(message);
            }
          }, 5000);
        }

      }

      // Initialize when DOM is ready
      document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('rainCanvas');
        if (canvas) {
          new RainController(canvas);
        }
      });
    </script>

  </body>

</html>
